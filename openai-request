#!/bin/env ruby

require 'net/http'
require 'optparse'
require 'base64'
require 'json'
require 'yaml'

def encode_file_as_base64(file_path)
  unless File.exist?(file_path)
    puts "File not found: #{file_path}"
    return nil
  end
  
  file_content = File.binread(file_path)
  encoded_content = Base64.strict_encode64(file_content)
  
  return encoded_content
end

def find_cfg
  pwd = Dir.pwd
  dirs = pwd.split('/')
  cfg = nil
  (dirs.size + 1).times do |i|
    path = dirs[0, dirs.size - i].join('/') + '/.openai.yaml'
    if File.exist?(path)
      cfg = YAML.load_file(path)
      break
    end
  end
  cfg
end

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: openai_requester.rb [options]"

  opts.on("--history-file [HISTORYFILE]", "Chat history file") do |history_file|
    if File.exists?(history_file)
      options[:history_file] = history_file
    end
  end

  opts.on("--prompt PROMPTSTRING", "Prompt string") do |prompt_string|
    options[:prompt_string] = prompt_string
  end

  opts.on("--prompt-file [PROMPTFILE]", "Prompt file") do |prompt_file|
    options[:prompt_file] = prompt_file
  end

  opts.on("--model MODEL", "Model string") do |model_string|
    options[:model_string] = model_string
  end

  opts.on("--outfile [FILE]", "Output file") do |out_file|
    options[:out_file] = out_file
  end

  opts.on("--token [TOKEN]", "OpenAI token") do |token|
    options[:token] = token
  end

  opts.on("--png [IMAGE]", "PNG file") do |png|
    options[:image] = png
  end
end.parse!

if options[:prompt_string].nil? && options[:prompt_file].nil?
  STDERR.puts "Error: Missing prompt"
  exit 1
end

cfg = find_cfg
if cfg.nil?
  STDERR.puts "Error: .openai.yaml not found"
  exit 1
end

token = options[:token]
if token.nil?
  STDERR.puts "Error: Token not found"
  exit 1
end

max_tokens = cfg['openai']['params']['max-tokens']
max_tokens ||= 150

n = cfg['openai']['params']['n']
n ||= 1

temperature = cfg['openai']['params']['temperature']
temperature ||= 0.7

model = options[:model_string]
if model.nil?
  model = cfg['openai']['model']
  if model.nil? || model == ''
    STDERR.puts "Error: Missing required argument '--model MODEL'"
    exit 1
  end
end

if options[:prompt_file]
  options[:prompt_string] = File.read(options[:prompt_file]).strip
end

history = []
history = File.read(options[:history_file]).split("\n").map { |line| JSON.parse(line) } if options[:history_file]

uri = URI("https://api.openai.com/v1/chat/completions")


example = {
  'event' => {
     'type' => 'click',
     'sector' => {
       'x' => 12,
       'y' => 13, 
     } 
   }
}
example2 = {
  'result' => 'pass or fail',
  'reason' => 'A sensible reason why pass or fail'
}
message = {
  "role" => "system",
  'content' => "You are a UI tester. The UI divided into sectors from 0 to 24 on X and Y axis. Answer in json like this event json:\n```json\n#{example.to_json}\n```\nor result json:\n```json\n#{example2.to_json}\n" 
}

history << message

message = {
  "role" => "user", 
}
# Is this a multimodal request?
if options[:image]
  # TODO currently just assume png ...
  image_data = encode_file_as_base64(options[:image])
  message['content'] = [
    {
      "type" => "image_url",
      "image_url" => {
        "url" => "data:image/png;base64,#{image_data}",
      },
    },
    {
      "type" => "text",
      "text" => options[:prompt_string],
    },
  ]
else
  message['content'] = options[:prompt_string]
end

history << message

request = Net::HTTP::Post.new(uri)
request.content_type = "application/json"
request["Authorization"] = "Bearer #{token}"

request.body = JSON.dump({
  "model" => model,
  "messages" => history,
  "max_tokens" => max_tokens,
  "n" => n,
  "top_p" => 0.1,
  "temperature" => 0.2,
#  "temperature" => temperature,
})

# puts request.body

begin
  response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
    http.read_timeout = 600
    http.request(request)
  end
rescue StandardError => e
  STDERR.puts e.to_s
  exit(1)
end

if response.is_a?(Net::HTTPSuccess)
  parsed_response = JSON.parse(response.body)
  completion = parsed_response["choices"][0]["message"]["content"]
  completion = completion.to_s + "\n"
  completion = completion.gsub(/^```.*\n/, '')
  if options[:out_file].nil?
    puts completion
  else
    File.open(options[:out_file], 'w') { |file| file.puts completion }
  end
else
  STDERR.puts "Error: #{response.message}"
  exit 1
end
